#if 0

bool badDecode(int addr, const char* l) {
  if (instrType(addr) != mark[addr] && mark[addr] != lost) return true;

  int dest = 0;
  switch (mark[addr]) {
    case jmp: dest = jmpDest(addr); break;
    case branch: dest = branchDest(addr); break;
    case call0: dest = call0Dest(addr); break;
  }
  if (dest) {
    char destStr[16];
    _itoa_s(base + dest, destStr, sizeof(destStr), 16);
    if (!strstr(l + 21, destStr)) return true;
  }
  return false;
}

#if 0
// find jx tables
for (int i = 0; i < topAddr; ++i)
  if ((text[i] & 0x3F) == 6 && (text[i + 3] & 0x3F) == 6) {
    int jt = i;
    do i += 3; while ((text[i] & 0x3F) == 6);
    int len = (i - jt) / 3;
    if (len >= 3)
      printf("jt %X %d\n", base + jt, len);
  }
return 0;
#endif

int storeText(char* l) { // returns addr
  int len = strlen(l);
  if (len < 25) return 0;
  if (l[8] != ':') return 0;

  int addr;
  sscanf(l, "%X", &addr);
  if (addr < base) return 0;
  addr -= base;

#if 0
  int bytes;
  sscanf(l + 10, "%X", &bytes);

  int mask = 0xFFFFFF;
  if (bytes <= 0xFFFF) {
    if (bytes <= 0xFF)
      mask = 0xFF;
    else mask = 0xFFFF;
  }

  if ((*(int*)(text + addr) & mask) != bytes)
    printf("Text differs @ %X\n", addr);
#endif

  return addr;

}

void readDisasm() {
  disasmAt(startSymbol);

  FILE* disasm = _fsopen("disasm.txt", "rt", _SH_DENYNO);
  if (!disasm) exit(5);
  char symbol[256];

  while (1) {
    bool done = false;
    char l[256];
    if (!fgets(l, sizeof(l), disasm)) break;

    int addr = storeText(l);
    if (addr <= 0) continue;

    mark[addr] = other;

    if (l[23] == '.') {
      mark[addr] = data;
      continue;
    }

    // TODO: better test!!
    if (addr >= 0x13e070 && addr <= 0x13f5e0
        || addr >= 0x13fb18 && addr <= 0x13fbcf
        || strstr(l, "..")) {
      mark[addr] = data;
      continue;
    }

    switch (l[21]) {
      case 'r': mark[addr] = ret; break; // ret.n
      case 'b': mark[addr] = branch; break;
    }

    switch (l[25]) {
      case 'c': if (l[26] == 'a')
        switch (l[29]) {
          case '0': mark[addr] = call0; break;
          case 'x': mark[addr] = l[30] == '0' ? callx0 : callxn; break;
          default: mark[addr] = lost; break;  // call4..12 objdump disasm out of sync
        }
              break;
      case 'b': if (l[29] != 'k') mark[addr] = branch; break;  // else break
      case 'j': mark[addr] = l[26] == 'x' ? jx : jmp; break;  // j, jx <reg>
      case 'l': if (l[28] == 'r') {
        mark[addr] = l32r;
        if (l[31] == '0')  break; // load a0 call dest
        int dest = l32rDest(addr);
        if (dest >= 0 && dest < max_size)  // some data is disasm'd !!!
          mark[dest] = data;
      }
              break;

      case 'r': if (l[26] == 'e' && l[27] == 't') mark[addr] = ret; break;
      case 'i': if (l[26] == 'l') mark[addr] = ill; break;
    }

    switch (mark[addr]) {
      case l32r:
      case call0:
        strcpy(symbol, strchr(l, '<') + 1);
        break;
    }

    switch (mark[addr]) {
      case ret:
      case ill:
        // done with this routine -- skip to next routine
        while (!(done = !fgets(l, sizeof(l), disasm))
               && l[0] != '-') // routine separator
          storeText(l);
        break;

      case call0:
      case callx0:
      case callxn:
        int dest = 0;
        switch (mark[addr]) {
          case call0: dest = call0Dest(addr); break;
          case callxn:  // ??
          case callx0: dest = l32rDest(addr - 3); break;
        }

        if (dest < 0) break;

        if (mark[dest] == unk) {
          mark[dest] = code;
          switch (mark[addr]) {
            case call0:
            case callx0:
            case callxn:
              *strchr(symbol, '>') = 0;
              if (strchr(symbol, '+')) // missing symbol!!
                disasmAt(base + dest, base + dest + 1024);
              else disasmAt(symbol);
              break;
          }
        }
        break;
    }

  #if 1 // check
    if (badDecode(addr, l))
      printf(l);
  #endif
    if (done) break;
  }
  fclose(disasm);
}
#endif